# 3. Числа. Строки

## Числа
### Числовые типы со знаком

| Тип данных | Размер (бит) | Минимальное значение | Максимальное значение | Пример |
|------------|--------------|----------------------|-----------------------|--------|
| `Byte`     | 8            | -128                 | 127                   | `val b: Byte = -128` |
| `Short`    | 16           | -32768               | 32767                 | `val s: Short = 0` |
| `Int`      | 32           | -2147483648          | 2147483647            | `val i: Int = 1` |
| `Long`     | 64           | -9223372036854775808 | 9223372036854775807   | `val l: Long = 10L` |
| `Float`    | 32           | -3.4e38              | 3.4e38                | `val f: Float = 3.4e38f` |
| `Double`   | 64           | -1.7e308             | 1.7e308               | `val d: Double = 1.7e308` |

В двоичном представление числа крайний левый бит выражает знак (0 — плюс или 1 — минус), а остальные биты выражают степени 2, где самый правый бит 2<sup>0</sup>. Например,  в типе `Byte`  двоичное представление `00101010` соответствует  42.

| 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 
|--|--|--|--|--|--|--|--|--| 
| + | 2<sup>6</sup> | 2<sup>5</sup> | 2<sup>4</sup> | 2<sup>3</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 

2<sup>5</sup> + 2<sup>3</sup> + 2<sup>1</sup>  = 32 + 8 + 2 = 42

###  Числовые литералы
> _Литерал_  (от англ. "literal" — буквальный) — это запись значения в исходном коде программы, которая представляет собой непосредственное значение.
> 
-   Целочисленные литералы:
        -   Десятичные:  `42`,  `-10`
        -   Шестнадцатеричные:  `0x2A`,  `0xFF`            
        -   Двоичные:  `0b101010`
        -   По умолчанию относятся к типу `Int`
        -   Для явного указания типа `Long` после числа добавляется суффикс `L`
-   Литералы с плавающей точкой:        
        -   `3.14`,  `-0.001`,  `2.718e10`
        - По умолчанию относятся к типу `Double`
        - Для явного указания типа `Float` после числа добавляется суффикс `f` или `F`

### Числовые константы 

#### Константы для максимальных и минимальных значений числовых типов данных

| Тип данных | Минимальное значение | Максимальное значение | 
|------------|----------------------|-----------------------| 
| `Byte` | `Byte.MIN_VALUE` | `Byte.MAX_VALUE` |
| `Short` | `Short.MIN_VALUE` | `Short.MAX_VALUE` |
| `Int` | `Int.MIN_VALUE` | `Int.MAX_VALUE` |
| `Long` | `Long.MIN_VALUE` | `Long.MAX_VALUE` |
| `Float` | `Float.MIN_VALUE` | `Float.MAX_VALUE` |
| `Double` | `Double.MIN_VALUE` | `Double.MAX_VALUE` |

#### Дополнительные константы для типов с плавающей точкой

| Тип данных | Отрицательная бесконечность | Положительная бесконечность | NaN (Not-a-Number) |
|------------|-----------------------------|-----------------------------|--------------------|
| `Float` | `Float.NEGATIVE_INFINITY` | `Float.POSITIVE_INFINITY` | `Float.NaN` |
| `Double` | `Double.NEGATIVE_INFINITY` | `Double.POSITIVE_INFINITY` | `Double.NaN` |

#### Математические константы

Импортируются из пакета `kotlin.math` 

`PI` — число π (пи), отношение длины окружности к её диаметру.
`E` — число e (экспонента), основание натурального логарифма.

### Погрешность вычислений с плавающей точкой

> Вычисления с плавающей точкой (floating-point arithmetic) — это метод представления и выполнения операций над числами с дробной частью. Однако, из-за ограниченной точности представления чисел в формате с плавающей точкой, возникает погрешность вычислений. Эта погрешность может привести к неожиданным результатам, особенно при выполнении сложных математических операций.

**Причины погрешности:**

1.  _Ограниченная точность_: числа с плавающей точкой представлены в виде конечного числа бит, что ограничивает точность их представления. Некоторые числа, такие как  `0.1`, не могут быть точно представлены в двоичном формате.
2.  _Округление_: при выполнении операций с плавающей точкой результаты округляются до ближайшего представимого значения, что приводит к потере точности.
3.  _Накопление ошибок_: при выполнении множества операций ошибки округления могут накапливаться, что приводит к значительной погрешности.

#### Примеры погрешности

**Сложение чисел с плавающей точкой:**
```kotlin
fun main() {
    val a = 0.1f
    val b = 0.2f
    val sum = a + b
    println("Сумма: $sum") // Вывод: 0.30000001
}
```
Результат сложения `0.1f` и `0.2f` не равен точно `0.3`, а немного больше. Это происходит из-за погрешности представления чисел с плавающей точкой.

**Сравнение чисел с плавающей точкой:**
```kotlin
fun main() {
    val a = 0.1f + 0.2f
    val b = 0.3f
    println("a == b: ${a == b}") // Вывод: false
}
```
Несмотря на то, что математически `0.1 + 0.2` должно быть равно `0.3`, в формате с плавающей точкой эти числа не равны из-за погрешности.

**Накопление ошибок:**
```kotlin
fun main() {
    var sum = 0.0
    for (i in 1..1000) {
        sum += 0.1
    }
    println("Сумма: $sum") // Вывод: 100.00000000000007
}
```
При многократном сложении числа `0.1` ошибки округления накапливаются, и результат не равен точно `100.0`.

#### Способы борьбы с погрешностью

_Эпсилон-сравнение:_ сравнивать числа с плавающей точкой с учетом небольшой погрешности (эпсилон).
```kotlin
fun main() {
    val a = 0.1f + 0.2f
    val b = 0.3f
    val epsilon = 1e-7f
    println("a == b: ${Math.abs(a - b) < epsilon}") // Вывод: true
}
```
_Типы данных с большей точностью:_ использовать  `Double`  вместо  `Float` или `BigDecimal` вместо `Double`.
_Математические библиотеки:_ использовать специализированные математические библиотеки, которые могут обеспечить более высокую точность вычислений.

### Преобразования числовых типов

#### Неявные преобразования
Неявные преобразования выполняются автоматически, когда типы данных совместимы.
```kotlin
fun main() {
    val intValue: Int = 42
    val longValue: Long = intValue // Неявное преобразование Int в Long
    val floatValue: Float = intValue // Неявное преобразование Int в Float
    val doubleValue: Double = intValue // Неявное преобразование Int в Double

    println("Long: $longValue") // 42
    println("Float: $floatValue") // 42.0
    println("Double: $doubleValue") // 42.0
}
```
#### Явные преобразования

Явные преобразования требуют использования специальных функций, таких как  `toByte()`,  `toShort()`,  `toInt()`,  `toLong()`,  `toFloat()`,  `toDouble()`.
```kotlin
fun main() {
    val byteValue: Byte = 42
    val shortValue: Short = byteValue.toShort() // Явное преобразование Byte в Short
    val intValue: Int = byteValue.toInt() // Явное преобразование Byte в Int
    val longValue: Long = byteValue.toLong() // Явное преобразование Byte в Long
    val floatValue: Float = byteValue.toFloat() // Явное преобразование Byte в Float
    val doubleValue: Double = byteValue.toDouble() // Явное преобразование Byte в Double

    println("Short: $shortValue") // 42
    println("Int: $intValue") // 42
    println("Long: $longValue") // 42
    println("Float: $floatValue") // 42.0
    println("Double: $doubleValue") // 42.0
}
```

#### Преобразования с потерей данных

При преобразовании чисел из типа с большей точностью в тип с меньшей точностью может произойти потеря данных. Например, при преобразовании  `Double`  в  `Float`  или  `Int`  в  `Byte`.

```kotlin
fun main() {
    val doubleValue: Double = 1234567890.123456789
    val floatValue: Float = doubleValue.toFloat() // Преобразование Double в Float с потерей точности
    val intValue: Int = doubleValue.toInt() // Преобразование Double в Int с потерей дробной части
    val byteValue: Byte = intValue.toByte() // Преобразование Int в Byte с потерей данных

    println("Float: $floatValue") // 1.23456794E9 (потеря точности)
    println("Int: $intValue") // 1234567890 (потеря дробной части)
    println("Byte: $byteValue") // -46 (потеря данных, выход за диапазон Byte)
}
```

#### Округление до ближайшего целого числа
Для округления числа до ближайшего целого числа можно использовать функцию `roundToInt()` или `roundToLong()`.

```kotlin
import kotlin.math.roundToInt
import kotlin.math.roundToLong

fun main() {
    val floatValue = 3.6f
    val doubleValue = 3.6

    val roundedInt = floatValue.roundToInt()
    val roundedLong = doubleValue.roundToLong()

    println("Округление Float до Int: $roundedInt") // 4
    println("Округление Double до Long: $roundedLong") // 4
}
```

#### Округление до указанного количества знаков после запятой

Для округления числа до указанного количества знаков после запятой можно использовать функцию  `String.format()`  или  `kotlin.math.round()`.
```kotlin
import kotlin.math.round

fun main() {
    val doubleValue = 3.1415926535

    val roundedValue = (doubleValue * 100).roundToInt() / 100.0
    println("Округление до 2 знаков после запятой: $roundedValue") // 3.14
}
```

### Числа без знака

Числовые типы данных без знака

| Тип данных | Размер (бит) | Минимальное значение | Максимальное значение | Пример |
|------------|--------------|----------------------|-----------------------|--------|
| `UByte`    | 8            | 0                    | 255                   | `val ub: UByte = 255u` |
| `UShort`   | 16           | 0                    | 65535                 | `val us: UShort = 0u` |
| `UInt`     | 32           | 0                    | 4294967295            | `val ui: UInt = 1u` |
| `ULong`    | 64           | 0                    | 18446744073709551615  | `val ul: ULong = 100uL` |

Эти типы данных позволяют работать с числами без знака, но их использование требует явного указания аннотации `@ExperimentalUnsignedTypes`.
```kotlin
@ExperimentalUnsignedTypes
fun main() {
	// Объявления переменных числовых типов без знака
    val ub: UByte = 255u
    val us: UShort = 65535u
    val ui: UInt = 4294967295u
    val ul: ULong = 18446744073709551615uL

    // Арифметические операции с числами без знака
    val sumUInt: UInt = 1000u + 2000u
    println("Сумма UInt: $sumUInt") // 3000
    val productULong: ULong = 1000000uL * 2000000uL
    println("Произведение ULong: $productULong") // 2000000000000

    // Преобразование между числами без знака
    val uintValue: UInt = ub.toUInt()
    println("Преобразование UByte в UInt: $uintValue") // 255
    val ulongValue: ULong = us.toULong()
    println("Преобразование UShort в ULong: $ulongValue") // 65535

    // Сравнение чисел без знака
    val isEqual: Boolean = ui == 4294967295u
    println("Сравнение UInt: $isEqual") // true
    val isGreater: Boolean = ul > 18446744073709551614uL
    println("Сравнение ULong: $isGreater") // true
}
```

### Системы счисления

> Система счисления — это способ представления чисел с помощью символов (цифр и букв). 

В Kotlin можно работать с числами в разных системах счисления таких как десятичная, двоичная, восьмеричная и шестнадцатеричная, используя специальные литералы и функции.

#### Десятичная система счисления

Десятичная система счисления (основание 10) использует только цифры от 0 до 9. Десятичные числа записываются как обычно.
```kotlin
fun main() {
    val decimalNumber = 42
    println("Десятичное число: $decimalNumber") // 42
}
```

#### Двоичная система счисления

Двоичная система счисления (основание 2) использует только две цифры: 0 и 1. Двоичные числа записываются с префиксом `0b`.
```kotlin
fun main() {
    val binaryNumber = 0b101010
    println("Двоичное число: $binaryNumber") // 42
}
```

#### Восьмеричная система счисления

Восьмеричная система счисления (основание 8) использует цифры от 0 до 7. Восьмеричные числа записываются с префиксом `0`.
```kotlin
fun main() {
    val octalNumber = 052
    println("Восьмеричное число: $octalNumber") // 42
}
```

#### Шестнадцатеричная система счисления

Шестнадцатеричная система счисления (основание 16) использует цифры от 0 до 9 и буквы от A до F (или a до f). В Kotlin шестнадцатеричные числа записываются с префиксом `0x`.
```kotlin
fun main() {
    val hexNumber = 0x2A
    println("Шестнадцатеричное число: $hexNumber") // 42
}
```

#### Преобразование между системами счисления

Преобразовывать числа из одной системы счисления в другую можно с помощью функций `toString()` и `toInt()`.
```kotlin
fun main() {
    val decimalNumber = 42

    // Преобразование десятичного числа в двоичное
    val binaryString = decimalNumber.toString(2)
    println("Двоичное представление: $binaryString") // 101010

    // Преобразование десятичного числа в восьмеричное
    val octalString = decimalNumber.toString(8)
    println("Восьмеричное представление: $octalString") // 52

    // Преобразование десятичного числа в шестнадцатеричное
    val hexString = decimalNumber.toString(16)
    println("Шестнадцатеричное представление: $hexString") // 2a

    // Преобразование двоичного числа в десятичное
    val binaryNumber = "101010".toInt(2)
    println("Десятичное представление двоичного числа: $binaryNumber") // 42

    // Преобразование восьмеричного числа в десятичное
    val octalNumber = "52".toInt(8)
    println("Десятичное представление восьмеричного числа: $octalNumber") // 42

    // Преобразование шестнадцатеричного числа в десятичное
    val hexNumber = "2A".toInt(16)
    println("Десятичное представление шестнадцатеричного числа: $hexNumber") // 42
}
```

### Битовые операции

> _Битовые операции_ — это операции, которые выполняются над битами чисел.

#### Список битовых операций

| Операция | Описание | Пример | Результат |
|----------|----------|--------|-----------|
| **Побитовое И (AND)** | Возвращает 1, если оба бита равны 1, иначе возвращает 0. | `val result = 0b1010 and 0b1100` | `0b1000` (8 в десятичной системе) |
| **Побитовое ИЛИ (OR)** | Возвращает 1, если хотя бы один из битов равен 1, иначе возвращает 0. | `val result = 0b1010 or 0b1100` | `0b1110` (14 в десятичной системе) |
| **Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)** | Возвращает 1, если биты различны, иначе возвращает 0. | `val result = 0b1010 xor 0b1100` | `0b0110` (6 в десятичной системе) |
| **Побитовое НЕ (NOT)** | Инвертирует все биты числа. | `val result = 0b1010.inv()` | `-0b1011` (-11 в десятичной системе) |
| **Сдвиг влево (shl)** | Сдвигает биты числа влево на указанное количество позиций. | `val result = 0b1010 shl 2` | `0b101000` (40 в десятичной системе) |
| **Сдвиг вправо (shr)** | Сдвигает биты числа вправо на указанное количество позиций. | `val result = 0b1010 shr 2` | `0b10` (2 в десятичной системе) |
| **Беззнаковый сдвиг вправо (ushr)** | Сдвигает биты числа вправо на указанное количество позиций, заполняя старшие биты нулями. | `val result = -0b1010 ushr 2` | `0b00111111111111111111111111111101` (1073741821 в десятичной системе) |

#### Пример использования битовых операций
```kotlin
fun main() {
    val a = 0b1010 // 10 в десятичной системе
    val b = 0b1100 // 12 в десятичной системе

    // Побитовое И (AND)
    val andResult = a and b
    println("Побитовое И: $andResult (в двоичной системе: ${andResult.toString(2)})") // 8 (1000 в двоичной системе)

    // Побитовое ИЛИ (OR)
    val orResult = a or b
    println("Побитовое ИЛИ: $orResult (в двоичной системе: ${orResult.toString(2)})") // 14 (1110 в двоичной системе)

    // Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)
    val xorResult = a xor b
    println("Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ: $xorResult (в двоичной системе: ${xorResult.toString(2)})") // 6 (0110 в двоичной системе)

    // Побитовое НЕ (NOT)
    val notResult = a.inv()
    println("Побитовое НЕ: $notResult (в двоичной системе: ${notResult.toString(2)})") // -11 (11111111111111111111111111110101 в двоичной системе)

    // Сдвиг влево (shl)
    val shlResult = a shl 2
    println("Сдвиг влево: $shlResult (в двоичной системе: ${shlResult.toString(2)})") // 40 (101000 в двоичной системе)

    // Сдвиг вправо (shr)
    val shrResult = a shr 2
    println("Сдвиг вправо: $shrResult (в двоичной системе: ${shrResult.toString(2)})") // 2 (10 в двоичной системе)

    // Беззнаковый сдвиг вправо (ushr)
    val ushrResult = -a ushr 2
    println("Беззнаковый сдвиг вправо: $ushrResult (в двоичной системе: ${ushrResult.toString(2)})") // 1073741821 (00111111111111111111111111111101 в двоичной системе)
}
```

## Строки

> _Строка_ — это упорядоченная последовательность символов, используемая для представления текста.

В Kotlin строки являются объектами типа `String`. Для создания строк можно использовать строковые литералы (текст внутри пары двойных кавычек).
```kotlin
fun main() {
    val str = "Привет, мир!"
    println(str)
}
```

### Основные свойства строк

#### Конкатенация

> _Конкатенация строк_ —  операция объединения двух или более строк в одну.

Конкатенация строк может быть выполнена с помощью оператора `+` или метода `plus()`.
```kotlin
fun main() {
    val str1 = "Привет" + "," + " " + "мир" + "!"
    println(str1)
    val str2 = "Привет".plus(",").plus(" ").plus("мир").plus("!")
    println(str2)
}
```

#### Неизменяемость
Строки являются объектами с неизменяемым состоянием, т.е. после создания строки ее содержимое не может быть изменено.  
```kotlin
fun main() { 
    val str = "Привет"
    // Любые операции, которые кажутся изменением строки, на самом деле создают новую строку
    str += ","
    str += " "
    str += "мир"
    str += "!" 
    println(str)
}
```

#### Интерполяция
_Интерполяция строк_ — встраивание выражения внутри строк с помощью символа  `$`.
```kotlin
fun main() {
    val name = "Иван"
    val age = 30
    val greeting = "Привет, $name! Тебе $age лет."

    println(greeting) // Привет, Иван! Тебе 30 лет.
}
```

#### Многострочные строки
Многострочные строки могут быть созданы с помощью тройных кавычек (`"""`). Это позволяет создавать строки, которые содержат переводы строк, табуляции и другие символы без необходимости экранирования.
```kotlin
fun main() {
    val multiLineString = """
        Это многострочная строка.
        Она может содержать переводы строк
        и другие символы.
    """

    println(multiLineString)
}
```

#### Работа с символами строки
К символам строки можно обращаться как к элементам массива

```kotlin
fun main() {
    val text = "Привет, мир!"

    // Доступ к символам строки
    println("Первый символ: ${text[0]}") // П
    println("Последний символ: ${text[text.length - 1]}") // !

    // Итерация по символам строки
    for (char in text) {
        println(char)
    }
}
```

### Обработка строк
Класс `String` предоставляет различные методы для работы со строками.

#### Длина строки
Метод `length` возвращает длину строки.
```kotlin
fun main() {
    val text = "Привет, мир!"
    println("Длина строки: ${text.length}") // 12
}
```

#### Получение символа по индексу
Метод `get` возвращает символ строки по указанному индексу.
```kotlin
fun main() {
    val text = "Привет, мир!"
    println("Последний символ: ${text.get(text.length - 1)}") // !
}
```

#### Поиск индекса подстроки
Метод `indexOf` возвращает индекс первого вхождения подстроки в строку.
```kotlin
fun main() {
    val text = "Привет, мир!"
    println("Индекс подстроки 'мир': ${text.indexOf("мир")}") // 8
}
```

#### Проверка на вхождение подстроки
Метод `contains` проверяет, содержится ли подстрока в строке.
```kotlin
fun main() {
    val text = "Привет, мир!"
    println("Содержит 'мир': ${text.contains("мир")}") // true
}
```

#### Извлечение подстроки
Метод `substring` возвращает подстроку, начиная с указанного индекса и до конца строки или до указанного индекса.
```kotlin
fun main() {
    val text = "Привет, мир!"
    println("Подстрока с 0 по 6: ${text.substring(0, 6)}") // Привет
    println("Подстрока с 8 до конца: ${text.substring(8)}") // мир!
}
```

#### Замена подстроки
Метод `replace` заменяет все вхождения подстроки на указанную строку.
```kotlin
fun main() {
    val text = "Привет, мир!"
    println("Замена 'мир' на 'вселенная': ${text.replace("мир", "вселенная")}") // Привет, вселенная!
}
```

#### Преобразование регистра
Методы `toUpperCase` и `toLowerCase` преобразуют строку в верхний и нижний регистр соответственно.
```kotlin
fun main() {
    val text = "Привет, мир!"
    println("Верхний регистр: ${text.toUpperCase()}") // ПРИВЕТ, МИР!
    println("Нижний регистр: ${text.toLowerCase()}") // привет, мир!
}
```

#### Удаление пробелов
Метод `trim` удаляет пробелы и другие символы пробелов в начале и конце строки.
```kotlin
fun main() {
    val text = "   Привет, мир!   "
    println("Удаление пробелов: ${text.trim()}") // Привет, мир!
}
```

#### Разделение строки
Метод `split` разбивает строку на массив строк по указанному разделителю.
```kotlin
fun main() {
    val text = "Привет,мир,вселенная"
    val parts = text.split(",")
    println("Разделение строки: $parts") // [Привет, мир, вселенная]
}
```

#### Объединение строк
Метод `joinToString` объединяет элементы коллекции в одну строку с указанным разделителем.
```kotlin
fun main() {
    val parts = listOf("Привет", "мир", "вселенная")
    val text = parts.joinToString(", ")
    println("Объединение строк: $text") // Привет, мир, вселенная
}
```

#### Проверка на пустую строку
Методы `isEmpty` и `isNotEmpty` проверяют, является ли строка пустой или непустой.
```kotlin
fun main() {
    val text = ""
    println("Строка пустая: ${text.isEmpty()}") // true
    println("Строка непустая: ${text.isNotEmpty()}") // false
}
```

#### Проверка на начало и конец строки
Методы `startsWith` и `endsWith` проверяют, начинается или заканчивается ли строка указанной подстрокой.
```kotlin
fun main() {
    val text = "Привет, мир!"
    println("Начинается с 'Привет': ${text.startsWith("Привет")}") // true
    println("Заканчивается на 'мир!': ${text.endsWith("мир!")}") // true
}
```

### Сравнение строк

Строки можно сравнивать с помощью операторов сравнения (`==`, `!=`, `<`, `>`, `<=`, `>=`) и методов класса `String`, таких как `equals`, `compareTo`.

#### Сравнение на равенство
Оператор `==` и метод `equals` проверяют, равны ли две строки по содержанию с учетом регистра. 

```kotlin
fun main() {
    val str1 = "Привет"
    val str2 = "Привет"
    val str3 = "Мир"

    println("str1 == str2: ${str1 == str2}") // true
    println("str1 == str3: ${str1 == str3}") // false

    println("str1.equals(str2): ${str1.equals(str2)}") // true
    println("str1.equals(str3): ${str1.equals(str3)}") // false
}
```

#### Сравнение без учета регистра
Метод `equalsIgnoreCase` сравнивает строки без учета регистра.
```kotlin
fun main() {
    val str1 = "Привет"
    val str2 = "привет"

    println("str1.equalsIgnoreCase(str2): ${str1.equalsIgnoreCase(str2)}") // true
}
```

#### Сравнение по лексикографическому порядку с учетом регистра
Метод  `compareTo`  сравнивает строки по лексикографическому порядку (алфавитному порядку). Он возвращает: 
-   Отрицательное число, если первая строка меньше второй.
-   Ноль, если строки равны.   
-   Положительное число, если первая строка больше второй.
```kotlin
fun main() {
    val str1 = "apple"
    val str2 = "banana"
    val str3 = "apple"

    println("str1.compareTo(str2): ${str1.compareTo(str2)}") // -1
    println("str1.compareTo(str3): ${str1.compareTo(str3)}") // 0
    println("str2.compareTo(str1): ${str2.compareTo(str1)}") // 1
}
```

#### Сравнение по лексикографическому порядку без учета регистра
Метод `compareToIgnoreCase` сравнивает строки по лексикографическому порядку без учета регистра.
```kotlin
fun main() {
    val str1 = "Apple"
    val str2 = "apple"

    println("str1.compareToIgnoreCase(str2): ${str1.compareToIgnoreCase(str2)}") // 0
}
```

### Преобразование строк в числа

Класс `String` предоставляет различные методы для преобразования строк в числа. Эти методы позволяют конвертировать строки в целочисленные типы (`Int`, `Long`, `Short`, `Byte`) и типы с плавающей точкой (`Float`, `Double`).

Пример преобразование строки в  целое число:
```kotlin
fun main() {
    val str = "42"
    val number: Int = str.toInt()
    println("Преобразование строки в Int: $number") // 42
}
```

Пример преобразование строки в  число с плавающей точкой:
```kotlin
fun main() {
    val str = "3.14159"
    val doubleValue: Double = str.toDouble()
    println("Преобразование строки в Double: $doubleValue") // 3.14159
}
```

### Регулярные выражения

> Регулярные выражения (Regular Expressions, Regex) — это предметно-ориентированный язык для поиска, сопоставления и манипуляции текстом.

#### Проверка соответствия строки шаблону
Метод `matches` проверяет, соответствует ли строка заданному регулярному выражению.
```kotlin
fun main() {
    val regex = Regex("^\\d{4}-\\d{2}-\\d{2}$")
    val date1 = "2023-10-05"
    val date2 = "2023-10-05T12:34:56"

    println("date1 соответствует шаблону: ${regex.matches(date1)}") // true
    println("date2 соответствует шаблону: ${regex.matches(date2)}") // false
}
```
Объяснение:
-   Регулярное выражение  `^\\d{4}-\\d{2}-\\d{2}$`  соответствует строке, содержащей дату в формате  `ГГГГ-ММ-ДД`.
-   `^`  и  `$`  обозначают начало и конец строки соответственно.
-   `\\d{4}`  соответствует четырем цифрам.
-   `-`  соответствует символу дефиса.
-   `\\d{2}`  соответствует двум цифрам.

#### Поиск подстроки по шаблону
Метод `matches` проверяет, соответствует ли строка заданному регулярному выражению.
```kotlin

```

#### Проверка соответствия строки шаблону
Метод `find` находит первое вхождение подстроки, соответствующей регулярному выражению.
```kotlin
fun main() {
    val regex = Regex("\\d+")
    val text = "У меня есть 3 яблока и 5 груш."

    val matchResult = regex.find(text)
    if (matchResult != null) {
        println("Найдено число: ${matchResult.value}") // 3
    } else {
        println("Число не найдено")
    }
}
```

#### Замена подстрок по шаблону
Метод `replace` заменяет все вхождения подстрок, соответствующих регулярному выражению, на указанную строку.
```kotlin
fun main() {
    val regex = Regex("\\d+")
    val text = "У меня есть 3 яблока и 5 груш."

    val replacedText = regex.replace(text, "X")
    println("Замененный текст: $replacedText") // У меня есть X яблока и X груш.
}
```

#### Разделение строки по шаблону
Метод `split` разбивает строку на массив строк по регулярному выражению.
```kotlin
fun main() {
    val regex = Regex("\\s+")
    val text = "Разделить эту строку на слова."

    val words = regex.split(text)
    println("Слова: $words") // [Разделить, эту, строку, на, слова.]
}
```

#### Группировка и захват подстрок
Регулярные выражения позволяют группировать части шаблона и захватывать соответствующие подстроки.
```kotlin
fun main() {
    val regex = Regex("(\\d{4})-(\\d{2})-(\\d{2})")
    val text = "Дата: 2023-10-05"

    val matchResult = regex.find(text)
    if (matchResult != null) {
        val (year, month, day) = matchResult.destructured
        println("Год: $year, Месяц: $month, День: $day") // Год: 2023, Месяц: 10, День: 05
    } else {
        println("Дата не найдена")
    }
}
```

Объяснение:
-   Регулярное выражение  `(\\d{4})-(\\d{2})-(\\d{2})`  соответствует строке, содержащей дату в формате  `ГГГГ-ММ-ДД`.
-   Скобки  `()`  обозначают группы, которые можно захватить и использовать отдельно.
-   Метод  `destructured`  позволяет получить значения захваченных групп в виде отдельных переменных.

## Задание


**Часть I**
1. **Погрешность вычислений с плавающей точкой**
Напишите программу, которая демонстрирует погрешность вычислений с плавающей точкой. Программа должна выполнять следующие действия: складывать, вычитать, умножать и делить числа с плавающей точкой и сравнивать результат вычисления с эталонным значением с помощью эпсилон-сравнения (например, результат сложения двух чисел 0,1 и 0,2 должен сравниваться с эталонным значением 0,3).
2. **Cистемы счисления**
Напишите программу, которая позволяет пользователю преобразовывать числа между различными системами счисления. Программа должна поддерживать следующие системы счисления: двоичная (base 2); восьмеричная (base 8); десятичная (base 10); шестнадцатеричная (base 16). Программа должна предоставлять пользователю возможность выбора исходной и целевой систем счисления, а также ввода числа для преобразования. Результат преобразования должен быть выведен на экран.
3. **Битовые операции**
Напишите программу, которая позволяет пользователю выполнять битовые операции над двумя целыми числами. Программа должна поддерживать следующие операции: побитовое И (`&`); побитовое ИЛИ (`|`); побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ (`^`); побитовое НЕ (`~`); сдвиг влево (`<<`); сдвиг вправо (`>>`); беззнаковый сдвиг вправо (`>>>`). Программа должна предоставлять пользователю возможность ввести два числа и выбрать операцию для выполнения. Результат операции должен быть выведен на экран.

**Часть II**
- **Обработка строк** 
Напишите программу, которая выполняет различные операции над строками. Программа должна предоставлять пользователю возможность выбирать операции и вводить строки для обработки. 
Программа должна поддерживать следующие операции над строками: подсчет количества символов в строке; подсчет количества слов в строке; преобразование строки в верхний регистр; преобразование строки в нижний регистр; удаление пробелов из строки; поиск подстроки в строке; замена подстроки в строке; разделение строки на слова; объединение слов в строку с заданным разделителем. Результаты выполнения операций должны быть выведены на экран.
- **Сравнение строк** 
Напишите программу, которая выполняет различные операции сравнения строк. Программа должна предоставлять пользователю возможность выбирать операции и вводить строки для сравнения. Программа должна поддерживать следующие операции сравнения строк: сравнение строк на равенство; сравнение строк с учетом регистра; сравнение строк без учета регистра; сравнение строк по длине; сравнение строк по лексикографическому порядку. Результаты операций должны быть выведены на экран.
- **Токенизация строк** 
Напишите программу, которая выполняет токенизацию строки на основе заданного разделителя. Программа должна предоставлять пользователю возможность вводить строку и разделитель, а затем выводить результат токенизации.

**Часть III**
- **Регулярные выражения** 
Напишите программу, которая использует регулярные выражения для выполнения различных операций над строками. Программа должна поддерживать следующие операции над строками с использованием регулярных выражений: проверка, соответствует ли строка заданному шаблону; поиск всех совпадений шаблона в строке; замена всех совпадений шаблона в строке на заданную подстроку; извлечение подстрок, соответствующих шаблону; разделение строки на подстроки по заданному шаблону. Программа должна предоставлять пользователю возможность выбирать операции и вводить строки для обработки. Результаты операций должны быть выведены на экран. Для проверки корректности работы программы использовать следующие примеры регулярных выражений: адреса электронной почты, даты, URL-ссылки, HTML-теги, SQL-запросы. 

## Вопросы

1. Числовые типы со знаком
2. Двоичное представление числа со знаком
3. Числовые литералы
4. Числовые константы
5. Причины погрешности вычислений с плавающей точкой
6. Способы борьбы с погрешностью
7. Преобразования числовых типов
8. Числа без знака
9. Системы счисления
10. Битовые операции
11. Создание строк
12. Конкатенация строк
13. Неизменяемость строк
14. Интерполяция строк
15. Многострочные строки 
16. Обращение к символам строк
17. Методы обработки строк
18. Сравнение строк на равенство
19. Сравнение строк по лексикографическому порядку 
20. Преобразование строк в числа
21. Регулярные выражения

## Ресурсы

- [Kotlin. Программирование для профессионалов. 2-е изд. Скин Д., Гринхол Д., Бэйли Э.](https://www.piter.com/collection/yazyki-programmirovaniya/product/kotlin-programmirovanie-dlya-professionalov-2-e-izd) Главы 5, 6
- [Kotlin docs: Numbers](https://kotlinlang.org/docs/numbers.html)
- [Kotlin docs: Unsigned integer types](https://kotlinlang.org/docs/unsigned-integer-types.html)
- [Kotlin docs: Strings](https://kotlinlang.org/docs/strings.html)
- [Руководство по языку Kotlin: Основные типы](https://kotlinlang.ru/docs/basic-types.html)
- [Java Platform Standard Edition 8 Documentation: Class Pattern](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)
