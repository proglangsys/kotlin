
# 15. Корутины

_Корутины (Coroutines)_ — это _легковесные потоки_, т.е. потоки, исполняемые в рамках одного процесса операционной системы. 

## Запуск корутины без возврата результата

Функция `launch`  запускает новую корутину в указанной области видимости без возврата результата ее выполнения.
```kotlin
launch {
	// Данный блок кода содержит инструкции запускаемой корутины
}
```

_Область видимости (Coroutine Scope)_ позволяет управлять временем жизни корутины и гарантирует, что корутина будет корректно завершена, если область видимости завершит свою работу.

### Глобальная область видимости

Глобальная область видимости доступна на протяжении всего времени работы приложения.
```kotlin
GlobalScope.launch {
    // Запуск корутины в глобальной области видимости
}
```

Пример запуска корутины в глобальной области видимости:
```kotlin
import kotlinx.coroutines.*

fun main() {
	// Запуск корутины в глобальной области видимости
    GlobalScope.launch {
	    // Данный блок кода содержит инструкции запускаемой корутины
        delay(1000L) // Неблокирующая задержка на одну секунду
        println("World!")
    }
    // Основной поток продолжает свою работу, не дожидаясь завершения сопрограммы
    println("Hello,")
    // Блокировка основного потока на две секунды, чтобы дождаться завершения сопрограммы
    Thread.sleep(2000L) 
}
```
Результат выполнения:
```text
Hello,
World!
```

### Блокирующая область видимости

Вызов функции `runBlocking` создает область видимости, которая блокирует текущий поток до завершения всех корутин внутри нее.
```kotlin
runBlocking {
    launch {
        // Запуск корутины в блокирующей области видимости
    }
}
```

Пример запуска корутины в блокирующей области видимости, в результате которого блокируется основной поток:
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch { // Запуск корутины в блокирующей области видимости
	    // Данный блок кода содержит инструкции запускаемой корутины
        delay(1000L)
        println("World!")
    }
    println("Hello,")
}
```

### Объекты типа `Job` (задачи)

Функция `launch`  возвращает объект типа  `Job` (называемый задачей), который можно использовать для управления жизненным циклом корутины (например, для ее отмены или ожидания завершения).
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    // Создаём и запускаем задачу
    val job = launch {
        delay(1000L)
        println("Task completed")
    }
}
```

### Ожидание завершения корутины

Вызов функции `join` у объекта типа `Job`, присоединяет соответствующую корутину к текущему потоку, т.е. потоку из которого вызвана данная функция. Выполнение данной операции приводит к тому, что текущий поток не будет завершен до тех пор, пока не завершится присоединенная к нему корутина.
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    // Создаём и запускаем задачу
    val job = launch {
        delay(1000L) // Неблокирующая задержка на одну секунду
        println("Task completed")
    }

    println("Task is active: ${job.isActive}") // true

    job.join() // Ожидаем завершения задачи

    println("Task is completed: ${job.isCompleted}") // true
    println("Task is cancelled: ${job.isCancelled}") // false
}
```

## Функции приостановки

Функции, отмеченные ключевым словом  `suspend`, могут приостанавливать своё выполнение, не блокируя текущий поток.
```kotlin
import kotlinx.coroutines.* 

fun main() = runBlocking {
	greeting()
	println("I am continue working") 
}

// Функция приостановки  
suspend  fun greeting() { 
	delay(1000L) // Задержка потока на одну секунду
	println("Hello World!") 
}
```

## Запуск корутины с возвратом результата

Функция `async` запускает корутины с возвратом результата ее выполнения. В отличие от `launch`, функция `async` возвращает объект типа `Deferred<T>`, который позволяет получить результат выполнения корутины. 
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val deferred = async {
        delay(1000L) // Имитация асинхронной работы
        0 // Возвращение некотрого результата
    }

    println("Waiting for result...")
    val result = deferred.await() // Получение результата
    println("Result: $result") // Вывод: "Result: 0"
} 
```

## Задания

**Часть 1**

Разработать программу, которая запускает несколько корутин параллельно, для генерации последовательности букв. 
Программа должна:
1.  Запускать корутины, каждая из которых генерирует уникальную букву английского алфавита (например, первая корутина генерирует букву "A", вторая — "B", и так далее). 
2.  Выводить сгенерированные буквы в командную строку.
3.  После завершения всех корутин вывести в командную строку статистику: сколько букв было сгенерировано каждой корутиной.

**Часть 2**

Разработать программу, которая ищет заданную строку в текстовых файлах параллельно с использованием корутин. 
Программа должна:
1. Принимать путь к директории с текстовыми файлами и строку для поиска.
2.  Формировать список файлов в данной директории и ее поддиректориях. 
3.  Запускать отдельную корутину поиска строки для каждого файла из списка.
4.  Выводить результаты поиска: список файлов, содержащих искомую строку, в командную строку.
5. Обрабатывать ошибки (например, если файл не найден).

**Часть 3**

Разработать программу, которая выполняет опрос нескольких серверов (командой ping) параллельно с использованием корутин. Программа должна:
1.  Принимать список адресов серверов (например, IP-адресов или доменных имен).
2.  Запускать отдельную корутину для опроса каждого сервера.
3.  Выводить результаты опроса серверов (доступен/недоступен) в командную строку.
4.  Обрабатывать ошибки (например, если сервер недоступен или адрес некорректен).

## Вопросы


## Ресурсы
- [Kotlin docs: Coroutines](https://kotlinlang.org/docs/coroutines-overview.html)
- [Руководство по языку Kotlin: Корутины](https://kotlinlang.ru/docs/coroutines-overview.html)