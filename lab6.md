# 6. Коллекции

## Списки

_Списки_ (List) представляют собой коллекции для хранения упорядоченного набора элементов. В Kotlin списки могут быть изменяемыми (mutable) и неизменяемыми (immutable).

### Создание списков

Неизменяемые списки создаются с помощью функции  `listOf()`. После создания такого списка его элементы не могут быть изменены.
```kotlin
val immutableList: List<Int> = listOf(1, 2, 3, 4, 5)
```

Изменяемые списки создаются с помощью функции `mutableListOf()`. В такие списки можно добавлять, удалять и изменять элементы.
```kotlin
val mutableList: MutableList<Int> = mutableListOf(1, 2, 3, 4, 5)
```

### Доступ к элементам списка
К элементам списка можно обращаться по индексу, используя квадратные скобки `[]`.
```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list[0])  // Выведет: 1
println(list[2])  // Выведет: 3
```

Также можно использовать метод `get()`, который делает то же самое.
```kotlin
println(list.get(0))  // Выведет: 1
```

### Безопасный доступ к элементам списка

Доступ к элементам списка по индексу может привести к ошибкам, если индекс выходит за пределы допустимого диапазона. Чтобы избежать таких ошибок, можно использовать безопасный доступ к элементам списка.

Метод `getOrElse` позволяет получить элемент по индексу, а если индекс выходит за пределы списка, вернуть значение по умолчанию, заданное в лямбда-выражении.
```kotlin
val list = listOf(1, 2, 3, 4, 5)
val element = list.getOrElse(10) { "Index out of bounds" }
println(element)  // Выведет: Index out of bounds
```

Метод `getOrNull` возвращает элемент по индексу, а если индекс выходит за пределы списка, возвращает `null`.
```kotlin
val list = listOf(1, 2, 3, 4, 5)
val element = list.getOrNull(10)
println(element)  // Выведет: null
```

Если необходимо найти элемент в списке, удовлетворяющий определенному условию, и при этом избежать ошибок, если такой элемент не найден, можно использовать метод  `find`.
```kotlin
val list = listOf(1, 2, 3, 4, 5)
val element = list.find { it > 3 }
println(element)  // Выведет: 4
```

### Добавление и удаление элементов списка

Для добавления элементов в изменяемый список используются методы `add()` и `addAll()`.
```kotlin
val mutableList = mutableListOf(1, 2, 3)
mutableList.add(4)  // Добавляем элемент 4 в конец списка
mutableList.addAll(listOf(5, 6))  // Добавляем список [5, 6] в конец списка
```

Для удаления элементов из изменяемого списка используются методы `remove()`, `removeAt()`, `removeAll()`.
```kotlin
mutableList.remove(3)  // Удаляем элемент со значением 3
mutableList.removeAt(0)  // Удаляем элемент по индексу 0
mutableList.removeAll(listOf(4, 5))  // Удаляем все элементы, которые есть в списке [4, 5]
```

### Итерация по списку

Списки можно перебирать с помощью цикла `for`.
```kotlin
val list = listOf(1, 2, 3, 4, 5)
for (item in list) {
    println(item)
}
```

Также можно использовать метод `forEach()`.
```kotlin
list.forEach { item -> println(item) }
```

### Другие полезные методы списков
-   `size`: Возвращает количество элементов в списке.
-   `isEmpty()`: Проверяет, пуст ли список.
-   `contains()`: Проверяет, содержится ли элемент в списке.
-   `indexOf()`: Возвращает индекс первого вхождения элемента в список.
-   `lastIndexOf()`: Возвращает индекс последнего вхождения элемента в список.
-   `subList()`: Возвращает подсписок, начиная с одного индекса и заканчивая другим.

```kotlin
val list = listOf(1, 2, 3, 4, 5)
println(list.size)  // Выведет: 5
println(list.isEmpty())  // Выведет: false
println(list.contains(3))  // Выведет: true
println(list.indexOf(4))  // Выведет: 3
println(list.subList(1, 3))  // Выведет: [2, 3]
```

### Преобразование списков
Списки можно преобразовывать с помощью методов `map()`, `filter()`, `sorted()`, `distinct()` и других.
```kotlin
val list = listOf(1, 2, 3, 4, 5)
val doubled = list.map { it * 2 }  // Удваиваем каждый элемент
val evenNumbers = list.filter { it % 2 == 0 }  // Фильтруем только четные числа
val sortedList = list.sorted()  // Сортируем список
val uniqueElements = list.distinct()  // Убираем дубликаты
```

## Деструктуризация

> _Деструктуризация_ (Destructuring) — это механизм, который позволяет распаковывать объекты (коллекции, пары, тройки, а также экземпляры пользовательских классов) на отдельные переменные. 

### Деструктуризация пар
Пары (Pair) позволяют распаковать два значения на две переменные.
```kotlin
val pair = Pair("one", 1)
val (first, second) = pair
println("First: $first, Second: $second")  // Выведет: First: one, Second: 1
```

### Деструктуризация троек
Тройки (Triple) позволяют распаковать три значения на три переменные.
```kotlin
val triple = Triple("one", 1, true)
val (first, second, third) = triple
println("First: $first, Second: $second, Third: $third")  // Выведет: First: one, Second: 1, Third: true
```

### Деструктуризация списков
Списки позволяют распаковать их элементы, но не более пяти, на отдельные переменные.
```kotlin
val list = listOf("one", "two", "three")
val (first, second, third) = list
println("First: $first, Second: $second, Third: $third")  // Выведет: First: one, Second: two, Third: three
```

### Деструктуризация с пропуском элементов
Если некоторые из распаковываемых значений не нужны, вместо переменных можно использовать подчеркивание `_` для пропуска ненужных значений.
```kotlin
val list = listOf("one", "two", "three", "four")
val (first, _, third, _) = list
println("First: $first, Third: $third")  // Выведет: First: one, Third: three
```

## Множества
_Множества_ (Set) представляют собой коллекции уникальных элементов. Каждый элемент в множестве встречается только один раз. Множества в Kotlin могут быть изменяемыми (mutable) и неизменяемыми (immutable).

### Создание множеств
Неизменяемые множества создаются с помощью функции  `setOf()`. После создания такого множества его элементы не могут быть изменены.
```kotlin
val immutableSet: Set<Int> = setOf(1, 2, 3, 4, 5)
```

Изменяемые множества создаются с помощью функции `mutableSetOf()`. В такие множества можно добавлять и удалять элементы.
```kotlin
val mutableSet: MutableSet<Int> = mutableSetOf(1, 2, 3, 4, 5)
```

### Доступ к элементам множества
В отличие от списков, множества не поддерживают доступ к элементам по индексу, так как они не упорядочены. Однако можно проверить, содержится ли элемент в множестве, используя метод `contains()`.
```kotlin
val set = setOf(1, 2, 3, 4, 5)
println(set.contains(3))  // Выведет: true
println(set.contains(6))  // Выведет: false
```

### Добавление и удаление элементов множества
Для добавления элементов в изменяемое множество используется метод `add()`.
```kotlin
val mutableSet = mutableSetOf(1, 2, 3)
mutableSet.add(4)  // Добавляем элемент 4
mutableSet.addAll(setOf(5, 6))  // Добавляем множество [5, 6]
```

Для удаления элементов из изменяемого множества используются методы `remove()`, `removeAll()`.
```kotlin
mutableSet.remove(3)  // Удаляем элемент со значением 3
mutableSet.removeAll(setOf(4, 5))  // Удаляем все элементы, которые есть в множестве [4, 5]
```

### Итерация по множеству
Множества можно перебирать с помощью цикла `for`.
```kotlin
val set = setOf(1, 2, 3, 4, 5)
for (item in set) {
    println(item)
}
```
Также можно использовать метод `forEach()`.
```kotlin
set.forEach { item -> println(item) }
```

### Другие полезные методы множеств
-   `size`: Возвращает количество элементов в множестве.    
-   `isEmpty()`: Проверяет, пусто ли множество.
-   `contains()`: Проверяет, содержится ли элемент в множестве.
-   `containsAll()`: Проверяет, содержатся ли все элементы из другого множества в данном множестве.
-   `union()`: Возвращает объединение двух множеств.
-   `intersect()`: Возвращает пересечение двух множеств.
-   `subtract()`: Возвращает разность двух множеств.

```kotlin
val set1 = setOf(1, 2, 3, 4, 5)
val set2 = setOf(4, 5, 6, 7, 8)

println(set1.size)  // Выведет: 5
println(set1.isEmpty())  // Выведет: false
println(set1.contains(3))  // Выведет: true
println(set1.containsAll(setOf(1, 2)))  // Выведет: true
println(set1.union(set2))  // Выведет: [1, 2, 3, 4, 5, 6, 7, 8]
println(set1.intersect(set2))  // Выведет: [4, 5]
println(set1.subtract(set2))  // Выведет: [1, 2, 3]
```

### Преобразование множеств
Множества можно преобразовывать с помощью методов  `map()`,  `filter()`,  `sorted()`,  `distinct()`  и других.
```kotlin
val set = setOf(1, 2, 3, 4, 5)
val doubled = set.map { it * 2 }  // Удваиваем каждый элемент
val evenNumbers = set.filter { it % 2 == 0 }  // Фильтруем только четные числа
val sortedSet = set.sorted()  // Сортируем множество
```

## Ассоциативные массивы (Словари)
Ассоциативные массивы (Map) хранят пары "ключ-значение". Каждый ключ уникален, и он используется для доступа к соответствующему значению. В Kotlin ассоциативный массив может быть изменяемым (mutable) и неизменяемым (immutable).

### Создание ассоциативных массивов

Неизменяемые ассоциативные массивы создаются с помощью функции  `mapOf()`. После создания такого ассоциативного массива его элементы не могут быть изменены.
```kotlin
val immutableMap: Map<String, Int> = mapOf("one" to 1, "two" to 2, "three" to 3)
```

Изменяемые ассоциативные массивы создаются с помощью функции `mutableMapOf()`. В таких ассоциативных массивах можно добавлять, удалять и изменять элементы.
```kotlin
val mutableMap: MutableMap<String, Int> = mutableMapOf("one" to 1, "two" to 2, "three" to 3)
```

### Доступ к элементам ассоциативного массива
К элементам ассоциативного массива можно обращаться по ключу, используя квадратные скобки `[]`.

```kotlin
val map = mapOf("one" to 1, "two" to 2, "three" to 3)
val value = map["one"]
println(value)  // Выведет: 1
```

Также можно использовать метод `get()`, который делает то же самое.
```kotlin
println(map.get("one"))  // Выведет: 1
```

### Безопасный доступ к элементам ассоциативного массива

Доступ к элементам ассоциативного массива по ключу может привести к ошибкам, если ключ отсутствует в массиве. Чтобы избежать таких ошибок, можно использовать безопасный доступ к элементам ассоциативного массива.

Метод `getOrDefault` позволяет получить значение по ключу, а если ключ отсутствует в ассоциативном массиве, вернуть значение по умолчанию.
```kotlin
println(map.getOrDefault("four", 0))  // Выведет: 0
```

Метод  `getOrElse`  позволяет получить значение по ключу, а если ключ отсутствует в массиве, вернуть значение, заданное в лямбда-выражении.
```kotlin
val map = mapOf("one" to 1, "two" to 2, "three" to 3)
val value = map.getOrElse("four") { "Key not found" }
println(value)  // Выведет: Key not found
```

Метод `getOrPut` позволяет получить значение по ключу, а если ключ отсутствует в массиве, добавить его в массив со значением, заданным в лямбда-выражении.
```kotlin
val mutableMap = mutableMapOf("one" to 1, "two" to 2, "three" to 3)
val value = mutableMap.getOrPut("four") { 4 }
println(value)  // Выведет: 4
println(mutableMap)  // Выведет: {one=1, two=2, three=3, four=4}
```

### Добавление и удаление элементов ассоциативного массива
Для добавления элементов в изменяемый ассоциативный массив используется метод `put()`.
```kotlin
val mutableMap = mutableMapOf("one" to 1, "two" to 2)
mutableMap.put("three", 3)  // Добавляем элемент "three" to 3
```

Также можно использовать оператор `[]` для добавления элементов.
```kotlin
mutableMap["four"] = 4  // Добавляем элемент "four" to 4
```

Для удаления элементов из изменяемого ассоциативного массива используется метод `remove()`.
```kotlin
mutableMap.remove("two")  // Удаляем элемент с ключом "two"
```

### Итерация по ассоциативному массиву
Ассоциативные массивы можно перебирать с помощью цикла `for`.
```kotlin
val map = mapOf("one" to 1, "two" to 2, "three" to 3)
for ((key, value) in map) {
    println("Key: $key, Value: $value")
}
```

Также можно использовать метод `forEach()`.
```kotlin
map.forEach { (key, value) -> println("Key: $key, Value: $value") }
```

### Другие полезные методы ассоциативных массивов
-   `size`: Возвращает количество элементов в ассоциативном массиве.
-   `isEmpty()`: Проверяет, пуст ли ассоциативный массив.
-   `containsKey()`: Проверяет, содержится ли ключ в ассоциативном массиве.
-   `containsValue()`: Проверяет, содержится ли значение в ассоциативном массиве.
-   `keys`: Возвращает множество всех ключей в ассоциативном массиве.
-   `values`: Возвращает коллекцию всех значений в ассоциативном массиве.
-   `entries`: Возвращает множество всех пар "ключ-значение" в ассоциативном массиве.

```kotlin
val map = mapOf("one" to 1, "two" to 2, "three" to 3)
println(map.size)  // Выведет: 3
println(map.isEmpty())  // Выведет: false
println(map.containsKey("two"))  // Выведет: true
println(map.containsValue(4))  // Выведет: false
println(map.keys)  // Выведет: [one, two, three]
println(map.values)  // Выведет: [1, 2, 3]
println(map.entries)  // Выведет: [one=1, two=2, three=3]
```

### Преобразование ассоциативных массивов
Ассоциативные массивы можно преобразовывать с помощью методов `map()`, `filter()`, `mapKeys()`, `mapValues()` и других.
```kotlin
val map = mapOf("one" to 1, "two" to 2, "three" to 3)
val doubledValues = map.mapValues { it.value * 2 }  // Удваиваем каждое значение
val filteredMap = map.filter { it.value % 2 == 0 }  // Фильтруем только четные значения
val mappedKeys = map.mapKeys { it.key.toUpperCase() }  // Преобразуем ключи в верхний регистр
```

## Задание


**Часть I**
 - **Работа со списками.** Создайте список целых чисел. Добавьте в него несколько элементов, удалите один из элементов и выведите список на экран.
 - **Работа с множествами.** Создайте два множества целых чисел. Найдите их пересечение и объединение, а затем выведите результаты на экран.
 - **Работа с ассоциативными массивами.** Создайте ассоциативный массив, где ключами будут строки, а значениями — целые числа. Добавьте несколько пар ключ-значение, затем выведите значение по одному из ключей.
 - **Деструктуризация пары.** Создайте пару (Pair) из двух элементов и используйте деструктуризацию для извлечения этих элементов в отдельные переменные. Выведите значения переменных на экран.
 - **Деструктуризация списка.** Создайте список из трех элементов и используйте деструктуризацию для извлечения этих элементов в отдельные переменные. Выведите значения переменных на экран.
 - **Деструктуризация с пропуском элементов.** Создайте список из пяти элементов. Используйте деструктуризацию для извлечения первого и последнего элементов, пропуская промежуточные. Выведите значения переменных на экран.
 - **Операции с элементами списка.** Создайте множество целых чисел. Напишите функцию, которая принимает список целых чисел и возвращает список следующих вычислений: сумму всех элементов; произведение всех элементов; максимальный элемент, минимальный элемент. Используйте деструктуризацию для извлечения элементов полученного списка вычислений в отдельные переменные. Выведите значения переменных на экран.

**Часть II**
 - **Разница списков.** Напишите функцию, которая принимает два списка целых чисел и возвращает новый список, содержащий элементы, которые есть в первом списке, но отсутствуют во втором.
 - **Объединение списков с уникальными элементами.** Напишите функцию, которая принимает два списка целых чисел и возвращает новый список, содержащий все уникальные элементы из обоих списков.
 - **Подмножество.** Напишите функцию, которая принимает два множества целых чисел и возвращает  `true`, если первое множество является подмножеством второго, и  `false`  в противном случае.
 - **Пересечение множеств с условием.** Напишите функцию, которая принимает два множества целых чисел и возвращает множество, содержащее элементы, которые есть в обоих множествах и являются простыми числами.
 - **Частота символов.** Напишите функцию, которая принимает строку и возвращает ассоциативный массив, где ключами являются символы строки, а значениями — количество их вхождений в строке.
 - **Объединение ассоциативных массивов.** Напишите функцию, которая принимает два ассоциативных массива и возвращает новый массив, содержащий все пары ключ-значение из обоих массивов. Если ключ присутствует в обоих массивах, значение должно быть суммой значений из обоих массивов.
 - **Фильтрация по ключам.** Напишите функцию, которая принимает ассоциативный массив и строку. Функция должна возвращать новый массив, содержащий только те пары ключ-значение, где ключ содержит заданную строку.
 - **Обратный поиск** Напишите функцию, которая принимает ассоциативный массив и значение. Функция должна возвращать множество ключей, которые соответствуют заданному значению.

**Часть III**

 - **Анализ данных с использованием списков пар и троек.** Имеется список транзакций, где каждая транзакция представлена парой (дата, сумма). Необходимо выполнить следующие задачи:
	 - Найти общую сумму всех транзакций.
	 - Найти самую крупную транзакцию и вывести её дату и сумму.
	 - Найти среднюю сумму транзакций.
	 - Сгруппировать транзакции по месяцам и найти общую сумму транзакций для каждого месяца. 
	 - Результат должен быть представлен в виде списка троек (год, месяц, общая сумма).
 - **Анализ данных с использованием ассоциативный массив.** Имеется ассоциативный массив продаж, где ключами являются названия товаров, а значениями — списки пар (дата продажи, количество проданных единиц). Необходимо выполнить следующие задачи:
	- Найти товар, который был продан наибольшее количество раз.
	- Найти товар, который принес наибольшую выручку (предположим, что у каждого товара есть фиксированная цена).
	- Вывести статистику по продажам за каждый месяц (общее количество проданных единиц и общая выручка).

## Вопросы
1. Списки
2. Пары
3. Тройки
4. Деструктуризация
5. Множества
6. Ассоциативные массивы

## Ресурсы
- [Kotlin. Программирование для профессионалов. 2-е изд. Скин Д., Гринхол Д., Бэйли Э.](https://www.piter.com/collection/yazyki-programmirovaniya/product/kotlin-programmirovanie-dlya-professionalov-2-e-izd) Главы 9, 10
- [Kotlin docs: Collections overview](https://kotlinlang.org/docs/collections-overview.html)
- [Kotlin docs: Constructing collections](https://kotlinlang.org/docs/constructing-collections.html)
- [Руководство по языку Kotlin: Коллекции. Общий обзор](https://kotlinlang.ru/docs/collections-overview.html)
- [Руководство по языку Kotlin: Создание коллекций](https://kotlinlang.ru/docs/constructing-collections.html)