# 2. Управляющие инструкции. Функции

## Управляющие инструкции

### Операторы сравнения

Список операторов сравнения с примерами:
| Оператор | Описание                  | Пример (a = 5, b = 3) | Результат |
|----------|---------------------------|------------------------|-----------|
| `==`     | Равно                     | `a == b`               | `false`   |
| `!=`     | Не равно                  | `a != b`               | `true`    |
| `>`      | Больше чем                | `a > b`                | `true`    |
| `<`      | Меньше чем                | `a < b`                | `false`   |
| `>=`     | Больше или равно          | `a >= b`               | `true`    |
| `<=`     | Меньше или равно          | `a <= b`               | `false`   |

Пример кода:
```kotlin
fun main() {
    val a = 5
    val b = 3

    println("a == b: ${a == b}")  // Вывод: a == b: false
    println("a != b: ${a != b}")  // Вывод: a != b: true
    println("a > b: ${a > b}")    // Вывод: a > b: true
    println("a < b: ${a < b}")    // Вывод: a < b: false
    println("a >= b: ${a >= b}")  // Вывод: a >= b: true
    println("a <= b: ${a <= b}")  // Вывод: a <= b: false
}
```

Объяснение:
-   `==`: Проверяет, равны ли два значения.
-   `!=`: Проверяет, не равны ли два значения.
-   `>`: Проверяет, больше ли левое значение, чем правое.
-   `<`: Проверяет, меньше ли левое значение, чем правое.
-   `>=`: Проверяет, больше или равно ли левое значение правому.
-   `<=`: Проверяет, меньше или равно ли левое значение правому.
    
Эти операторы возвращают логическое значение (`true`  или  `false`) в зависимости от результата сравнения.

### Логические операторы

Список логических операторов с примерами:
| Оператор | Описание                  | Пример (a = true, b = false) | Результат |
|----------|---------------------------|------------------------------|-----------|
| `&&`     | Логическое И              | `a && b`                     | `false`   |
| `||`     | Логическое ИЛИ            | `a || b`                     | `true`    |
| `!`      | Логическое НЕ             | `!a`                         | `false`   |

Пример кода:
```kotlin
fun main() {
    val a = true
    val b = false

    println("a && b: ${a && b}")  // Вывод: a && b: false
    println("a || b: ${a || b}")  // Вывод: a || b: true
    println("!a: ${!a}")          // Вывод: !a: false
}
```

Объяснение:
-   `&&`: Возвращает  `true`, если оба операнда истинны.
-   `||`: Возвращает  `true`, если хотя бы один из операндов истинен.
-   `!`: Инвертирует значение операнда (преобразует  `true`  в  `false`  и наоборот).
    
Эти операторы возвращают логическое значение (`true`  или  `false`) в зависимости от результата логической операции.

### Условия if/else

> _Условие_ — это логическое выражение, которое может быть либо истинным (`true`), либо ложным (`false`). Условия используются для управления потоком выполнения программы: выполнения определенных блоков кода только при выполнении заданных условий.

Конструкция `if/else` предполагает, что блок кода, следующий за оператором `if` выполняется, если логическое выражение, записанное в качестве его условия, истинно; в противном случае, выполняется блок кода, следующий за оператором `else`.

Пример кода:
```kotlin
fun main() {
    val a = 5
    val b = 3

    // Проверка, равны ли значения a и b
    if (a == b) {
        println("a и b равны")
    } else {
        println("a и b не равны")
    }
}
```

Блок-кода с единственным выражением можно не выделять фигурными скобками:
```kotlin
fun main() {
    val s = "Kotlin"

    // Проверка, равна ли строка s константе "Kotlin"
    if (s == "Kotlin")
        println("Строка равна 'Kotlin'")
    else
        println("Строка не равна 'Kotlin'")
}
```

Множественное ветвление:
```kotlin
fun main() {
    val score = 75
    // Определение оценки по баллам с использованием множественного ветвления
    if (score >= 80) {
        println("ОТЛ")
    } else if (score >= 70) {
        println("ХОР")
    } else if (score >= 60) {
        println("УДОВЛ")
    } else {
        println("НЕУД")
    }
}
```

### Интервалы

> _Интервалы_ — структура данных, которая служит для представления линейного набора значений целочисленных или символьного типов данных.

Создание интервала с помощью оператора  `..`:
```kotlin
val intRange: IntRange = 1..100  // Интервал от 1 до 100 включительно
val charRange: CharRange = 'a'..'z'  // Интервал от 'a' до 'z' включительно
```
Создание интервала с помощью функции  `rangeTo`:
```kotlin
val range = 1.rangeTo(100)  // То же самое, что и 1..100
```

Проверка принадлежности значения интервалу, используя оператор  `in`:
```kotlin
val x = 7
if (x in 1..10) {
    println("x находится в интервале от 1 до 10")
} else {
    println("x не находится в интервале от 1 до 10")
}
```

### Условные выражения if/else

Результат выполнения конструкции `if/else` можно присвоить переменной.

Пример кода:
```kotlin
fun main() {
    val score = 75
    // Определение оценки по баллам с использованием множественного ветвления
	
	val grade: String = 
    if (score >= 80)
        "ОТЛ"
    else if (score >= 70)
        "ХОР"
    else if (score >= 60)
        "УДОВЛ"
    else
        "НЕУД"
    
    println(grade)    
}
```

### Условные выражения when

Конструкция `when` позволяет определить группу условий и выполнить код, соответствующий истинному условию.

Конструкция `when` c аргументом:
```kotlin
fun main() {
    val dayOfWeek = 3

    // Определение дня недели с использованием оператора when с аргументом
    val dayName = when (dayOfWeek) {
        1 -> "Понедельник"
        2 -> "Вторник"
        3 -> "Среда"
        4 -> "Четверг"
        5 -> "Пятница"
        6 -> "Суббота"
        7 -> "Воскресенье"
        else -> "Неверный день недели"
    }

    println("День недели: $dayName")
}
```

Конструкция `when` без аргумента:
```kotlin
fun main() {
    val score = 75

    // Определение оценки по баллам с использованием оператора when
    val grade = when {
        score >= 80 -> "ОТЛ"
        score >= 70 -> "ХОР"
        score >= 60 -> "УДОВЛ"
        else -> "НЕУД"
    }

    println("Оценка: $grade")
}
```

Конструкция `when` с объявлением переменной:
```kotlin
fun main(args: Array<String>) {
    str = args[0]
    when (val length = str.length) {
        0 -> println("Empty string")
        1 -> println("Single character string")
        else -> println("String with $length characters")
    }
}
```

### Цикл for

> _Цикл_ — это конструкция, которая позволяет повторять выполнение
> определенного блока кода несколько раз.

Цикл `for` служит для перебора элементов массивов, коллекций и интервалов.

Перебор элементов массива:
```kotlin
fun main() {
    val numbers = arrayOf(1, 2, 3, 4, 5)

    for (number in numbers) {
        println(number)
    }
}
```

Перебор элементов списка:
```kotlin
fun main() {
    val fruits = listOf("Apple", "Banana", "Cherry")

    for (fruit in fruits) {
        println(fruit)
    }
}
```

Перебор пар ключ-значение ассоциативного массива:
```kotlin
fun main() {
    val map = mapOf("a" to 1, "b" to 2, "c" to 3)

    for ((key, value) in map) {
        println("Key: $key, Value: $value")
    }
}
```

Перебор интервала:
```kotlin
fun main() {
    for (i in 1..5) {
        println(i)
    }
}
```

Перебор интервала с условием и шагом в прямом порядке:
```kotlin
fun main() {
    for (i in 0 until 10 step 2) {
        println(i)
    }
}
```

Перебор интервала с условием и шагом в обратном порядке:
```kotlin
fun main() {
    for (i in 10 downTo 1 step 2) {
        println(i)
    }
}
```

### Циклы while и do-while

Циклы `while` и `do-while` позволяют определить условие выхода из цикла.

Пример кода с использованием цикла `while`:
```kotlin
fun main() {
    var count = 0

    while (count < 5) {
        println("Count: $count")
        count++
    }
}
```

Пример кода с использованием цикла `do-while`:
```kotlin
fun main() {
    var input: String

    do {
        print("Введите 'exit' для выхода: ")
        input = readLine() ?: ""
        println("Вы ввели: $input")
    } while (input != "exit")
}
```

### Инструкции перехода

Инструкция `break` — выход из цикла:
```kotlin
fun main() {
    for (i in 1..10) {
        if (i == 5) {
            println("Выход из цикла при i = $i")
            break
        }
        println("i = $i")
    }
}
```

Инструкция `continue` — выход из текущей итерации цикла и перехода к следующей:
```kotlin
fun main() {
    for (i in 1..10) {
        if (i % 2 == 0) {
            println("Пропуск четных чисел")
            continue
        }
        println("i = $i")
    }
}
```

### Инструкции перехода с метками

Инструкции перехода можно использовать совместно с метками для управления вложенными циклами. 

Выход из внешнего цикла:
```kotlin
fun main() {
    outerLoop@ for (i in 1..3) {
        for (j in 1..3) {
            if (i == 2 && j == 2) {
                println("Выход из внешнего цикла при i = $i, j = $j")
                break@outerLoop
            }
            println("i = $i, j = $j")
        }
    }
}
```

Выход из итерации внешнего цикла:
```kotlin
fun main() {
    outerLoop@ for (i in 1..3) {
        for (j in 1..3) {
            if (i == 2 && j == 2) {
                println("Пропуск итерации внешнего цикла при i = $i, j = $j")
                continue@outerLoop
            }
            println("i = $i, j = $j")
        }
    }
}
```

## Функции

> Функция — это блок кода, который выполняет определенную задачу и может быть вызван из других частей программы. Функции позволяют структурировать код, делая его более модульным, читаемым и повторно используемым. Они могут принимать аргументы (параметры) и возвращать результат.

### Объявление, реализация и вызов функции

Основные элементы функции:
1.  _Имя_ — уникальное имя (идентификатор), по которому функция может быть вызвана.
2.  _Параметры_ — значения, которые передаются в функцию для обработки.
3.  _Тело_ — блок кода, который выполняется при вызове функции.
4.  _Возвращаемое значение_ — результат, который функция возвращает после выполнения.

Пример функции и ее вызова:
```kotlin
fun greet(name: String) {
    println("Привет, $name!")
}

fun main() {
    greet("Алиса")  // Вызов функции с аргументом
}
```

Инструкция выхода из функции `return`:

```kotlin
fun multiply(a: Int, b: Int): Int {
    return a * b
}

fun main() {
    val result = multiply(4, 6)  // Вызов функции и сохранение результата
    println("Результат умножения: $result")
}
```

### Именованные аргументы

При вызове функции можно использовать именованные аргументы. Это позволяет явно указывать, какому параметру какое значение передается, что делает код более читаемым и уменьшает вероятность ошибок, связанных с неправильным порядком аргументов.

Пример функции для вычисления площади прямоугольника:
```kotlin
fun calculateRectangleArea(width: Double, height: Double): Double {
    return width * height
}
```

Примеры вызовов функции с именованными аргументами:
```kotlin
fun main() {
    // Вызов функции с именованными аргументами
    val area1 = calculateRectangleArea(width = 10.0, height = 5.0)
    println("Площадь прямоугольника: $area1")

    // Вызов функции с изменением порядка аргументов
    val area2 = calculateRectangleArea(height = 7.0, width = 3.0)
    println("Площадь прямоугольника: $area2")

    // Вызов функции с частичным использованием именованных аргументов
    val area3 = calculateRectangleArea(12.0, height = 4.0)
    println("Площадь прямоугольника: $area3")
}
```

### Аргументы по умолчанию

При объявлении функции можно определить аргументы со значениями по умолчанию. Это позволяет вызывать функцию без необходимости передавать все аргументы.
```kotlin
fun calculateRectangleArea(width: Double = 1.0, height: Double = 1.0): Double {
    return width * height
}

fun main() {
    // Вызов функции без аргументов
    val area1 = calculateRectangleArea()
    println("Площадь прямоугольника: $area1")  // Вывод: Площадь прямоугольника: 1.0

    // Вызов функции с одним именованным аргументом
    val area2 = calculateRectangleArea(width = 10.0)
    println("Площадь прямоугольника: $area2")  // Вывод: Площадь прямоугольника: 10.0

    // Вызов функции с другим именованным аргументом
    val area3 = calculateRectangleArea(height = 5.0)
    println("Площадь прямоугольника: $area3")  // Вывод: Площадь прямоугольника: 5.0
    
    // Вызов функции с двумя именованными аргументами
    val area4 = calculateRectangleArea(width = 10.0, height = 5.0)
    println("Площадь прямоугольника: $area4")  // Вывод: Площадь прямоугольника: 50.0
}
```

### Перегрузка функций

> _Перегрузка_ — это механизм, который позволяет создавать несколько функций с одинаковым именем, но разными параметрами. Это позволяет вызывать одну и ту же функцию с разным набором аргументов, что делает код более гибким и удобным для использования.

```kotlin
fun calculateRectangleArea(width: Double, height: Double): Double {
    return width * height
}

fun calculateRectangleArea(side: Double): Double {
    return calculateRectangleArea(side, side)
}

fun calculateRectangleArea(): Double {
    return calculateRectangleArea(1.0, 1.0)
}

fun main() {
    // Вызов функции без аргументов
    val area1 = calculateRectangleArea()
    println("Площадь прямоугольника: $area1")  // Вывод: Площадь прямоугольника: 1.0

    // Вызов функции с одним аргументом
    val area2 = calculateRectangleArea(10.0)
    println("Площадь прямоугольника: $area2")  // Вывод: Площадь прямоугольника: 100.0

    // Вызов функции с двумя аргументами
    val area3 = calculateRectangleArea(10.0, 5.0)
    println("Площадь прямоугольника: $area3")  // Вывод: Площадь прямоугольника: 50.0
}
```

### Функции с единственным выражением

Если тело функции содержит единственное выражение можно не выделать его фигурными скобками и не включать инструкцию выхода `return`.

Пример функции с единственным выражением для вычисления факториала числа _n_:

```kotlin
fun factorial(n: Int): Int = if (n <= 1) 1 else n * factorial(n - 1)

fun main() {
    val number = 5
    println("Факториал числа $number: ${factorial(number)}")  // Вывод: Факториал числа 5: 120
}
```

### Возвращаемый тип Unit

Возвращаемый тип `Unit` используется для обозначения отсутствия возвращаемого значения. Функция, которая не возвращает никакого значения, может быть объявлена с типом возвращаемого значения `Unit`. Это аналогично `void` в других языках программирования.

```kotlin
fun greet(name: String): Unit {
    println("Привет, $name!")
}

fun main() {
    greet("Алиса")  // Вывод: Привет, Алиса!
}
```

## Задание

**Часть I**

- **Проверка числа на простоту.** Напишите функцию  `isPrime`, которая принимает целое число _n_ и возвращает  `true`, если оно простое, и  `false`  в противном случае. Используйте цикл  `for`  и условие  `if`. (Число  _n_ считать с клавиатуры.)
- **Подсчет суммы цифр числа.** Напишите функцию  `sumOfDigits`, которая принимает целое число и возвращает сумму его цифр. Используйте цикл  `while`  и оператор  `%`. (Число  _n_ считать с клавиатуры.)
- **Подсчет количеств четных цифр в числе.** Напишите функцию `countOfEnenDigits`, которая принимает целое число _n_ и возвращает количество его четных цифр. (Число  _n_ считать с клавиатуры.)

**Часть II**
- **Площадь эллипса.** Напишите функцию `calculateEllipseArea`, которая вычисляет площадь эллипса. Функция должна принимать два параметра: длину большой полуоси _a_ и длину малой полуоси _b_. Используйте формулу для вычисления площади эллипса: _π×a×b_. В объявлении функции использовать аргументы по умолчанию  _a = 1_ и _b = 1_; при вызове функции использовать именованные аргументы. (Числа  _a_ и _b_ считать с клавиатуры.)
- **Площадь эллипса (с перегрузкой)** Напишите три перегруженных функции `calculateEllipseArea`, каждая из которых вычисляет площадь эллипса. Одна из них должна принимать два параметра: длину большой полуоси _a_ и длину малой полуоси _b_. Другая функция должна принимать один параметр _a_, когда длины большой и малой полуоси совпадают. Последняя функция должна быть безаргументной.
- **Таблица умножения 10х10.** Напишите функцию `genMultiplicationTable', которая принимает два целых числа _n_ и _m_ и  выводит на экран таблицу умножения nхm (n на m). В объявлении функции использовать аргументы по умолчанию  _n = 10_ и _m = 10_; при вызове функции использовать именованные аргументы. (Числа  _n_ и _m_ считать с клавиатуры; при выводе таблицы умножения в качестве разделителя использовать табуляцию.)
Пример вывода на экран при _n = 10_ и _m = 10_:
```
1	2	3	4	5	6	7	8	9	10
2	4	6	8	10	12	14	16	18	20
3	6	9	12	15	18	21	24	27	30
4	8	12	16	20	24	28	32	36	40
5	10	15	20	25	30	35	40	45	50
6	12	18	24	30	36	42	48	54	60
7	14	21	28	35	42	49	56	63	70
8	16	24	32	40	48	56	64	72	80
9	18	27	36	45	54	63	72	81	90
10	20	30	40	50	60	70	80	90	100
```

**Часть III**
 - **Игра "Угадай число".** Программа должна случайным образом генерировать число в диапазоне от 1 до 100, а пользователь должен угадать это число. Программа должна давать подсказки, указывая, является ли введенное пользователем число больше или меньше загаданного. Игра продолжается до тех пор, пока пользователь не угадает число. Использовать цикл `while`, множественное ветвление `when` и инструкцию перехода `break`. 
- **Игра "Лабиринт".** Лабиринт представляет собой двумерный массив, где `0`  — свободное пространство; `1`  — стена; `2`  — начальная позиция игрока; `3`  — выход из лабиринта. Игрок может перемещаться с помощью соответствующих команд `u`  — вверх, `d` — вниз, `l` — влево и `r` — вправо. Игра заканчивается, когда игрок достигает выхода. Используйте инструкцию перехода  `break`  с меткой для выхода из внешнего цикла, когда игрок достигает выхода.
Пример работы программы:
```
Лабиринт:
0 0 1 0 0
0 0 1 0 0
0 0 1 0 0
0 2 1 0 3
0 0 0 0 0

Введите направление (u/d/l/r): d
Лабиринт:
0 0 1 0 0
0 0 1 0 0
0 0 1 0 0
0 0 1 0 3
0 2 0 0 0

Введите направление (u/d/l/r): r
Лабиринт:
0 0 1 0 0
0 0 1 0 0
0 0 1 0 0
0 0 1 0 3
0 0 2 0 0

Введите направление (w/a/s/d): r
Лабиринт:
0 0 1 0 0
0 0 1 0 0
0 0 1 0 0
0 0 1 0 3
0 0 0 2 0
```
## Вопросы

1. Условие
2. Логическое выражение
3. Операторы сравнения
4. Логические операторы
5. Интервалы
6. Условные выражения  `if/else` 
7. Множественное ветвление
8. Условные выражения `when` 
9. `when` без аргумента
10. `when` с объявлением переменной
11. Циклы
12. Инструкции перехода
13. Инструкции перехода с метками
14. Функции
15. Именованные аргументы
16. Аргументы по умолчанию
17. Перегрузка функций

## Ресурсы

- [Kotlin. Программирование для профессионалов. 2-е изд. Скин Д., Гринхол Д., Бэйли Э.](https://www.piter.com/collection/yazyki-programmirovaniya/product/kotlin-programmirovanie-dlya-professionalov-2-e-izd) Главы 3, 4
- [Kotlin docs: Conditions and loops](https://kotlinlang.org/docs/control-flow.html)
- [Kotlin docs: Returns and jumps](https://kotlinlang.org/docs/returns.html)
- [Kotlin docs: Functions](https://kotlinlang.org/docs/functions.html)
- [Руководство по языку Kotlin: Функции](https://kotlinlang.ru/docs/functions.html)
- [Руководство по языку Kotlin: Условия и циклы](https://kotlinlang.ru/docs/control-flow.html)
- [Руководство по языку Kotlin: Операторы перехода](https://kotlinlang.ru/docs/returns.html)
