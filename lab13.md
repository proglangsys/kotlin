
# 13. Расширения

_Расширения_ позволяют добавлять новые методы и свойства к существующим классам без необходимости наследования.

## Функции-расширения
_Функции-расширения_ позволяют добавлять новые методы к классам. 

Объявление и реализация функции-расширения:
```kotlin
fun <Класс>.имяФункции(параметры): ВозвращаемыйТип {
    // Тело функции
}
```

Пример: функция `isEven` расширяет класс `Int`, добавляя новое поведение его объектам, а именно проверяет, является ли число четным.
```kotlin
fun Int.isEven(): Boolean {
    return this % 2 == 0
}

fun main() {
    val number = 4
    println(number.isEven()) // true
}
```

## Обобщенные функции-расширения

Функции-расширения могут быть обобщенными, т.е. быть применимыми для расширения обобщенных типов. 

Объявления и реализация обобщенной функции-расширения:
```kotlin
fun <T> <Класс>.имяФункции(параметры): ВозвращаемыйТип {
    // Тело функции
}
```

Пример: функция `second` расширяет обобщенный класс `List<T>`, добавляя новое поведение его объектам, а именно возвращает второй элемент списка.
```kotlin
fun <T> List<T>.second(): T? {
    return if (this.size >= 2) this[1] else null
}

fun main() {
    val list = listOf(1, 2, 3, 4)
    println(list.second()) // 2
}
```

## Свойства-расширения

Свойства-расширения позволяют добавлять новые свойства к классам. Синтаксис для объявления свойства-расширения выглядит следующим образом:
```kotlin
val <Класс>.имяСвойства: ВозвращаемыйТип
    get() {
        // Тело геттера
    }
```

Пример: свойство `positive` расширяет класс `Int`, добавляя новое поведение его объектам, а именно проверяет, является ли число положительным.
```kotlin
val Int.positive: Boolean
    get() = this > 0

fun main() {
    val number = 5
    println(number.positive) // true
}
```

## Наследование расширений
Расширения базовых классов наследуются производными классами.

Пример наследования функции-расширения:
```kotlin
// Базовый класс
open class Animal(val name: String)

// Функция-расширение базового класса
fun Animal.makeSound() {
    println("${this.name} makes a sound")
}

// Производный класс                              
class Dog(name: String) : Animal(name)

// Демонстрация
fun main() {
    val dog = Dog("Buddy")
    dog.makeSound()  // Вывод: Buddy makes a sound
}   
```

Пример наследования свойства-расширения:
```kotlin
// Базовый класс
open class Animal(val name: String)

// Свойство-расширение базового класса
val Animal.fullName: String
    get() = "Animal: $name"

// Производный класс
class Dog(name: String) : Animal(name)

// Демонстрация работы
fun main() {
    val dog = Dog("Buddy")
    println(dog.fullName)  // Вывод: Animal: Buddy
}    
```

## Переопределение расширений

Расширения базовых классов могут быть переопределены в производных классах, если они имеют одинаковый сигнатурный тип.

Пример переопределения унаследованной функции-расширения:
```kotlin
// Базовый класс
open class Animal(val name: String)

// Функция-расширение базового класса
fun Animal.makeSound() {
    println("${this.name} makes a sound")
}

// Производный класс
class Dog(name: String) : Animal(name)

// Функция-расширение производного класса
fun Dog.makeSound() {
    println("${this.name} barks")
}

// Демонстрация работы
fun main() {
    val dog = Dog("Buddy")
    dog.makeSound()  // Вывод: Buddy barks
}
```

Пример переопределения унаследованного свойства-расширения:
```kotlin
// Базовый класс
open class Animal(val name: String)

// Свойство-расширение базового класса
val Animal.fullName: String
    get() = "Animal: $name"

// Производный класс
class Dog(name: String) : Animal(name)

// Свойство-расширение производного класса
val Dog.fullName: String
    get() = "Dog: $name"

// Демонстрация работы
fun main() {
    val dog = Dog("Buddy")
    println(dog.fullName)  // Вывод: Dog: Buddy
}
```

## Статическая диспетчеризация расширений

Расширения вычисляются статически, то есть компилятор выбирает функцию-расширение на основе статического типа переменной, а не её динамического (т.е. определяемого во время исполнения) типа. Это означает, что если есть переменная с типом базового класса, но она ссылается на объект производного класса, будет вызвана функция-расширение для базового класса.
```kotlin
open class Vehicle

class Car : Vehicle()

fun Vehicle.start() {
    println("Vehicle is starting")
}

fun Car.start() {
    println("Car is starting")
}

fun main() {
    val vehicle: Vehicle = Car()
    vehicle.start() // Вывод: Vehicle is starting
}
```

## Расширение null-допустимых типов

Расширения могут быть определены для null-допустимых типов, что позволяет обрабатывать случаи, когда объект может быть `null`.

Пример: функция `safeSquare` расширяет класс `Int?`, добавляя новое поведение его объектам, а именно возвращает квадрат числа или `null`, если число равно `null`.
```kotlin
fun Int?.safeSquare(): Int? {
    return this?.let { it * it }
}

fun main() {
    val number1: Int? = 5
    val number2: Int? = null
    println(number1.safeSquare()) // 25
    println(number2.safeSquare()) // null
}
```

## Расширения в качестве членов класса

Расширения могут быть определены внутри класса, что позволяет использовать их только в контексте этого класса.

Пример функции `add`, расширяющей класс `Int` внутри класса `Calculator`.

```kotlin
class Calculator {
    fun Int.add(other: Int): Int {
        return this + other
    }

    fun calculate(a: Int, b: Int): Int {
        return a.add(b)
    }
}

fun main() {
    val calculator = Calculator()
    println(calculator.calculate(3, 4)) // 7
}
```

## Задание

**Часть I** 

- Создайте функцию-расширение `isPalindrome()` для класса `String`, которая проверяет, является ли строка палиндромом (читается одинаково слева направо и справа налево).
- Создайте обобщенную функцию-расширение `swap()` для любого типа `T`, которая меняет местами два элемента в списке по индексам.
- Создайте функцию-расширение `printClassName()` для суперкласса `Any`, которая выводит имя класса объекта.
- Создайте свойство-расширение `lastChar` для класса `String`, которое возвращает последний символ строки.
- Создайте функцию-расширение `safeLength()` для класса `String?`, которая возвращает длину строки или `null`, если строка равна `null`.
- Создайте класс `Calculator`, который содержит функцию-расширение `square()` для типа `Int`, которая возвращает квадрат числа.
- Создайте класс `Person` (персона) с полями `firstName` (имя),  `lastName` (фамилия) и `age` (возраст). Создайте функцию-расширение `isAdult()` для класса `Person`, которая проверяет, является ли человек совершеннолетним. Также создайте свойство-расширение `fullName` для класса `Person`, которое возвращает полное имя, включающее имя и фамилию.

**Часть II**
Создайте набор функций-расширения для работы с геометрическими фигурами. 
- Классы для геометрических фигур:
    -   `Point`;
    -   `Rectangle`;
    -   `Ellipse`.        
- Реализовать следующие функции-расширения:
    -   Для класса  `Point`:        
        -   `distanceTo(other: Point): Double`  — расстояние до другой точки.
        -   `translate(dx: Double, dy: Double): Point`  — перемещение точки на заданные смещения по осям  `x`  и  `y`.
    -   Для класса  `Rectangle`:
        -   `area(): Double`  — площадь прямоугольника.
        -   `contains(point: Point): Boolean`  — проверка, содержится ли точка внутри прямоугольника.
        -   `intersects(other: Rectangle): Boolean`  — проверка, пересекается ли прямоугольник с другим прямоугольником.
        -    Для класса  `Ellipse`:
        -   `area(): Double`  — площадь эллипса.
        -   `contains(point: Point): Boolean`  — проверка, содержится ли точка внутри эллипса.   
-   Создайте обобщенную функцию-расширение  `move(dx: Double, dy: Double)`  для любой фигуры, которая перемещает фигуру на заданные смещения по осям  `x`  и  `y`.
   
 **Часть III**
Создайте набор функций-расширения для работы с графами.
- Классы для представления графа:
    -   `Node`  с уникальным идентификатором  `id`  и списком соседей  `neighbors`.
    -   `Graph`  с множеством узлов  `nodes`.
- Реализовать следующие функции-расширения:
    -   Для класса  `Node`:
        -   `addNeighbor(neighbor: Node)`  — добавление соседа к узлу. 
        -   `removeNeighbor(neighbor: Node)`  — удаление соседа из узла.  
        -   `hasNeighbor(neighbor: Node): Boolean`  — проверка, является ли узел соседом.
    -   Для класса  `Graph`:
        -   `addNode(node: Node)`  — добавление узла в граф. 
        -   `removeNode(node: Node)`  — удаление узла из графа.       
        -   `findNodeById(id: Int): Node?`  — поиск узла по идентификатору.     
        -   `breadthFirstSearch(startId: Int, targetId: Int): List<Int>?`  — поиск в ширину (BFS) от узла с идентификатором  `startId`  до узла с идентификатором  `targetId`. Возвращает путь в виде списка идентификаторов узлов или  `null`, если путь не найден.
        -   `depthFirstSearch(startId: Int, targetId: Int): List<Int>?`  — поиск в глубину (DFS) от узла с идентификатором  `startId`  до узла с идентификатором  `targetId`. Возвращает путь в виде списка идентификаторов узлов или  `null`, если путь не найден.

## Вопросы

## Ресурсы
- [Kotlin docs: Extensions](https://kotlinlang.org/docs/extensions.html)
- [Руководство по языку Kotlin: Расширения](https://kotlinlang.ru/docs/extensions.html)